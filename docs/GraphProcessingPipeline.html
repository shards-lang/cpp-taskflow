<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Learning from Examples &raquo; Graph Processing Pipeline | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="Examples.html">Learning from Examples</a> &raquo;</span>
          Graph Processing Pipeline
        </h1>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#FormulateTheGraphProcessingPipelineProblem">Formulate the Graph Processing Pipeline Problem</a></li>
            <li>
              <a href="#CreateAGraphProcessingPipeline">Create a Graph Processing Pipeline</a>
              <ul>
                <li><a href="#GraphPipelineFindATopologicalOrderOfTheGraph">Find a Topological Order of the Graph</a></li>
                <li><a href="#GraphPipelineDefineTheStageFunction">Define the Stage Function</a></li>
                <li><a href="#GraphPipelineDefineThePipes">Define the Pipes</a></li>
                <li><a href="#GraphPipelineDefineTheTaskGraph">Define the Task Graph</a></li>
                <li><a href="#GraphPipelineSubmitTheTaskGraph">Submit the Task Graph</a></li>
              </ul>
            </li>
            <li><a href="#GraphPipelineReference">Reference</a></li>
          </ul>
        </nav>
<p>We study a graph processing pipeline that propagates a sequence of linearly dependent tasks over a dependency graph. In this particular workload, we will learn how to transform task graph parallelism into pipeline parallelism.</p><section id="FormulateTheGraphProcessingPipelineProblem"><h2><a href="#FormulateTheGraphProcessingPipelineProblem">Formulate the Graph Processing Pipeline Problem</a></h2><p>Given a directed acyclic graph (DAG), where each node encapsulates a sequence of linearly dependent tasks, namely <em>stage tasks</em>, and each edge represents a dependency between two tasks at the same stages of adjacent nodes. For example, assuming <code>fi(u)</code> represents the <code>i</code><sup>th</sup>-stage task of node <code>u</code>, a dependency from <code>u</code> to <code>v</code> requires <code>fi(u)</code> to run before <code>fi(v)</code>. The following figures shows an example of three stage tasks in a DAG of three nodes (<code>A</code>, <code>B</code>, and <code>C</code>) and two dependencies (<code>A-&gt;B</code> and <code>A-&gt;C</code>):</p><div class="m-graph"><svg style="width: 18.000rem; height: 14.800rem;" viewBox="0.00 0.00 180.00 148.00">
<g transform="scale(1 1) rotate(0) translate(4 144)">
<title>L</title>
<g class="m-node m-flat">
<title>a</title>
<polygon points="124,-140 47,-140 47,-88 124,-88 124,-140"/>
<text text-anchor="start" x="55" y="-128" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">[Node A]</text>
<text text-anchor="start" x="55" y="-117" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 1: f1(A)</text>
<text text-anchor="start" x="55" y="-106" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 2: f2(A)</text>
<text text-anchor="start" x="55" y="-95" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 3: f3(A)</text>
</g>
<g class="m-node m-flat">
<title>b</title>
<polygon points="77,-52 0,-52 0,0 77,0 77,-52"/>
<text text-anchor="start" x="8" y="-40" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">[Node B]</text>
<text text-anchor="start" x="8" y="-29" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 1: f1(B)</text>
<text text-anchor="start" x="8" y="-18" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 2: f2(B)</text>
<text text-anchor="start" x="8" y="-7" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 3: f3(B)</text>
</g>
<g class="m-edge">
<title>a&#45;&gt;b</title>
<path d="M71.3985,-87.5971C66.9433,-79.2555 61.9486,-69.9037 57.2229,-61.0557"/>
<polygon points="60.228,-59.2529 52.4296,-52.081 54.0535,-62.5507 60.228,-59.2529"/>
</g>
<g class="m-node m-flat">
<title>c</title>
<polygon points="172,-52 95,-52 95,0 172,0 172,-52"/>
<text text-anchor="start" x="103" y="-40" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">[Node C]</text>
<text text-anchor="start" x="103" y="-29" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 1: f1(C)</text>
<text text-anchor="start" x="103" y="-18" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 2: f2(C)</text>
<text text-anchor="start" x="103" y="-7" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Step 3: f3(C)</text>
</g>
<g class="m-edge">
<title>a&#45;&gt;c</title>
<path d="M99.9016,-87.5971C104.4515,-79.2555 109.5525,-69.9037 114.3787,-61.0557"/>
<polygon points="117.5581,-62.536 119.274,-52.081 111.4128,-59.184 117.5581,-62.536"/>
</g>
</g>
</svg>
</div><p>While we can directly create a taskflow for the DAG (i.e., each task in the taskflow runs <code>f1</code>, <code>f2</code>, and <code>f3</code> sequentially), we can describe the parallelism as a three-stage pipeline that propagates a topological order of the DAG through three stage tasks. Consider a valid topological order of this DAG, <code>A, B, C</code>, its pipeline parallelism can be illustrated in the following figure:</p><div class="m-graph"><svg style="width: 20.600rem; height: 33.200rem;" viewBox="0.00 0.00 206.00 332.00">
<g transform="scale(1 1) rotate(0) translate(4 328)">
<title>R</title>
<g class="m-node m-flat">
<title>f1_A</title>
<polygon points="54,-324 0,-324 0,-288 54,-288 54,-324"/>
<text text-anchor="middle" x="27" y="-303.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f1(A)</text>
</g>
<g class="m-node m-flat">
<title>f1_B</title>
<polygon points="54,-252 0,-252 0,-216 54,-216 54,-252"/>
<text text-anchor="middle" x="27" y="-231.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f1(B)</text>
</g>
<g class="m-edge">
<title>f1_A&#45;&gt;f1_B</title>
<path d="M27,-287.8314C27,-280.131 27,-270.9743 27,-262.4166"/>
<polygon points="30.5001,-262.4132 27,-252.4133 23.5001,-262.4133 30.5001,-262.4132"/>
</g>
<g class="m-node m-flat">
<title>f2_A</title>
<polygon points="126,-252 72,-252 72,-216 126,-216 126,-252"/>
<text text-anchor="middle" x="99" y="-231.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f2(A)</text>
</g>
<g class="m-node m-flat">
<title>f2_B</title>
<polygon points="126,-180 72,-180 72,-144 126,-144 126,-180"/>
<text text-anchor="middle" x="99" y="-159.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f2(B)</text>
</g>
<g class="m-edge">
<title>f2_A&#45;&gt;f2_B</title>
<path d="M99,-215.8314C99,-208.131 99,-198.9743 99,-190.4166"/>
<polygon points="102.5001,-190.4132 99,-180.4133 95.5001,-190.4133 102.5001,-190.4132"/>
</g>
<g class="m-node m-flat">
<title>f3_A</title>
<polygon points="198,-180 144,-180 144,-144 198,-144 198,-180"/>
<text text-anchor="middle" x="171" y="-159.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f3(A)</text>
</g>
<g class="m-node m-flat">
<title>f3_B</title>
<polygon points="198,-108 144,-108 144,-72 198,-72 198,-108"/>
<text text-anchor="middle" x="171" y="-87.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f3(B)</text>
</g>
<g class="m-edge">
<title>f3_A&#45;&gt;f3_B</title>
<path d="M171,-143.8314C171,-136.131 171,-126.9743 171,-118.4166"/>
<polygon points="174.5001,-118.4132 171,-108.4133 167.5001,-118.4133 174.5001,-118.4132"/>
</g>
<g class="m-edge">
<title>f1_B&#45;&gt;f2_A</title>
<path d="M54.2813,-234C60.104,-234 65.9268,-234 71.7495,-234"/>
</g>
<g class="m-node m-flat">
<title>f1_C</title>
<polygon points="54,-180 0,-180 0,-144 54,-144 54,-180"/>
<text text-anchor="middle" x="27" y="-159.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f1(C)</text>
</g>
<g class="m-edge">
<title>f1_B&#45;&gt;f1_C</title>
<path d="M27,-215.8314C27,-208.131 27,-198.9743 27,-190.4166"/>
<polygon points="30.5001,-190.4132 27,-180.4133 23.5001,-190.4133 30.5001,-190.4132"/>
</g>
<g class="m-edge">
<title>f2_B&#45;&gt;f3_A</title>
<path d="M126.2813,-162C132.104,-162 137.9268,-162 143.7495,-162"/>
</g>
<g class="m-node m-flat">
<title>f2_C</title>
<polygon points="126,-108 72,-108 72,-72 126,-72 126,-108"/>
<text text-anchor="middle" x="99" y="-87.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f2(C)</text>
</g>
<g class="m-edge">
<title>f2_B&#45;&gt;f2_C</title>
<path d="M99,-143.8314C99,-136.131 99,-126.9743 99,-118.4166"/>
<polygon points="102.5001,-118.4132 99,-108.4133 95.5001,-118.4133 102.5001,-118.4132"/>
</g>
<g class="m-node m-flat">
<title>f3_C</title>
<polygon points="198,-36 144,-36 144,0 198,0 198,-36"/>
<text text-anchor="middle" x="171" y="-15.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f3(C)</text>
</g>
<g class="m-edge">
<title>f3_B&#45;&gt;f3_C</title>
<path d="M171,-71.8314C171,-64.131 171,-54.9743 171,-46.4166"/>
<polygon points="174.5001,-46.4132 171,-36.4133 167.5001,-46.4133 174.5001,-46.4132"/>
</g>
<g class="m-edge">
<title>f1_C&#45;&gt;f2_B</title>
<path d="M54.2813,-162C60.104,-162 65.9268,-162 71.7495,-162"/>
</g>
<g class="m-edge">
<title>f2_C&#45;&gt;f3_B</title>
<path d="M126.2813,-90C132.104,-90 137.9268,-90 143.7495,-90"/>
</g>
</g>
</svg>
</div><p>At the beginning, <code>f1(A)</code> runs first. When <code>f1(A)</code> completes, it moves on to <code>f2(A)</code> and, meanwhile, <code>f1(B)</code> can start to run together with <code>f2(A)</code>, and so on so forth. The straight line represents two parallel tasks that can overlap in time in the pipeline. For example, <code>f3(A)</code>, <code>f2(B)</code>, and <code>f1(C)</code> can run simultaneously. The following figures shows the task dependency graph of this pipeline workload:</p><div class="m-graph"><svg style="width: 20.600rem; height: 18.800rem;" viewBox="0.00 0.00 206.00 188.00">
<g transform="scale(1 1) rotate(0) translate(4 184)">
<title>R</title>
<g class="m-node m-flat">
<title>f1_A</title>
<polygon points="54,-180 0,-180 0,-144 54,-144 54,-180"/>
<text text-anchor="middle" x="27" y="-159.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f1(A)</text>
</g>
<g class="m-node m-flat">
<title>f1_B</title>
<polygon points="126,-180 72,-180 72,-144 126,-144 126,-180"/>
<text text-anchor="middle" x="99" y="-159.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f1(B)</text>
</g>
<g class="m-edge">
<title>f1_A&#45;&gt;f1_B</title>
<path d="M54.2813,-162C56.7377,-162 59.1942,-162 61.6507,-162"/>
<polygon points="61.7495,-165.5001 71.7495,-162 61.7495,-158.5001 61.7495,-165.5001"/>
</g>
<g class="m-node m-flat">
<title>f2_A</title>
<polygon points="54,-108 0,-108 0,-72 54,-72 54,-108"/>
<text text-anchor="middle" x="27" y="-87.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f2(A)</text>
</g>
<g class="m-edge">
<title>f1_A&#45;&gt;f2_A</title>
<path d="M27,-143.8314C27,-136.131 27,-126.9743 27,-118.4166"/>
<polygon points="30.5001,-118.4132 27,-108.4133 23.5001,-118.4133 30.5001,-118.4132"/>
</g>
<g class="m-node m-flat">
<title>f1_C</title>
<polygon points="198,-180 144,-180 144,-144 198,-144 198,-180"/>
<text text-anchor="middle" x="171" y="-159.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f1(C)</text>
</g>
<g class="m-edge">
<title>f1_B&#45;&gt;f1_C</title>
<path d="M126.2813,-162C128.7377,-162 131.1942,-162 133.6507,-162"/>
<polygon points="133.7495,-165.5001 143.7495,-162 133.7495,-158.5001 133.7495,-165.5001"/>
</g>
<g class="m-node m-flat">
<title>f2_B</title>
<polygon points="126,-108 72,-108 72,-72 126,-72 126,-108"/>
<text text-anchor="middle" x="99" y="-87.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f2(B)</text>
</g>
<g class="m-edge">
<title>f1_B&#45;&gt;f2_B</title>
<path d="M99,-143.8314C99,-136.131 99,-126.9743 99,-118.4166"/>
<polygon points="102.5001,-118.4132 99,-108.4133 95.5001,-118.4133 102.5001,-118.4132"/>
</g>
<g class="m-node m-flat">
<title>f2_C</title>
<polygon points="198,-108 144,-108 144,-72 198,-72 198,-108"/>
<text text-anchor="middle" x="171" y="-87.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f2(C)</text>
</g>
<g class="m-edge">
<title>f1_C&#45;&gt;f2_C</title>
<path d="M171,-143.8314C171,-136.131 171,-126.9743 171,-118.4166"/>
<polygon points="174.5001,-118.4132 171,-108.4133 167.5001,-118.4133 174.5001,-118.4132"/>
</g>
<g class="m-edge">
<title>f2_A&#45;&gt;f2_B</title>
<path d="M54.2813,-90C56.7377,-90 59.1942,-90 61.6507,-90"/>
<polygon points="61.7495,-93.5001 71.7495,-90 61.7495,-86.5001 61.7495,-93.5001"/>
</g>
<g class="m-node m-flat">
<title>f3_A</title>
<polygon points="54,-36 0,-36 0,0 54,0 54,-36"/>
<text text-anchor="middle" x="27" y="-15.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f3(A)</text>
</g>
<g class="m-edge">
<title>f2_A&#45;&gt;f3_A</title>
<path d="M27,-71.8314C27,-64.131 27,-54.9743 27,-46.4166"/>
<polygon points="30.5001,-46.4132 27,-36.4133 23.5001,-46.4133 30.5001,-46.4132"/>
</g>
<g class="m-edge">
<title>f2_B&#45;&gt;f2_C</title>
<path d="M126.2813,-90C128.7377,-90 131.1942,-90 133.6507,-90"/>
<polygon points="133.7495,-93.5001 143.7495,-90 133.7495,-86.5001 133.7495,-93.5001"/>
</g>
<g class="m-node m-flat">
<title>f3_B</title>
<polygon points="126,-36 72,-36 72,0 126,0 126,-36"/>
<text text-anchor="middle" x="99" y="-15.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f3(B)</text>
</g>
<g class="m-edge">
<title>f2_B&#45;&gt;f3_B</title>
<path d="M99,-71.8314C99,-64.131 99,-54.9743 99,-46.4166"/>
<polygon points="102.5001,-46.4132 99,-36.4133 95.5001,-46.4133 102.5001,-46.4132"/>
</g>
<g class="m-node m-flat">
<title>f3_C</title>
<polygon points="198,-36 144,-36 144,0 198,0 198,-36"/>
<text text-anchor="middle" x="171" y="-15.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">f3(C)</text>
</g>
<g class="m-edge">
<title>f2_C&#45;&gt;f3_C</title>
<path d="M171,-71.8314C171,-64.131 171,-54.9743 171,-46.4166"/>
<polygon points="174.5001,-46.4132 171,-36.4133 167.5001,-46.4133 174.5001,-46.4132"/>
</g>
<g class="m-edge">
<title>f3_A&#45;&gt;f3_B</title>
<path d="M54.2813,-18C56.7377,-18 59.1942,-18 61.6507,-18"/>
<polygon points="61.7495,-21.5001 71.7495,-18 61.7495,-14.5001 61.7495,-21.5001"/>
</g>
<g class="m-edge">
<title>f3_B&#45;&gt;f3_C</title>
<path d="M126.2813,-18C128.7377,-18 131.1942,-18 133.6507,-18"/>
<polygon points="133.7495,-21.5001 143.7495,-18 133.7495,-14.5001 133.7495,-21.5001"/>
</g>
</g>
</svg>
</div><p>As we can see, tasks in diagonal lines (lower-left to upper-right) can run in parallel. This type of parallelism is also referred to as <em>wavefront</em> parallelism, which sweeps parallel elements in a diagonal direction.</p><aside class="m-note m-info"><h4>Note</h4><p>Depending on the graph size and the number of stage tasks, task graph parallelism and pipeline parallelism can bring very different performance results. For example, a small graph will a long chain of stage tasks may perform better with pipeline parallelism than task graph parallelism, and vice versa.</p></aside></section><section id="CreateAGraphProcessingPipeline"><h2><a href="#CreateAGraphProcessingPipeline">Create a Graph Processing Pipeline</a></h2><p>Using the example from the previous section, we create a three-stage pipeline that encapsulates the three stage tasks (<code>f1, f2, f3</code>) in three pipes. By finding a topological order of the graph, we can transform the node dependency into a sequence of linearly dependent data tokens to feed into the pipeline. The overall implementation is shown below:</p><pre class="m-code"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;taskflow/taskflow.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;taskflow/algorithm/pipeline.hpp&gt;</span><span class="cp"></span>

<span class="c1">// 1st-stage function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f1(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 2nd-stage function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f2(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 3rd-stage function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f3(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">(</span><span class="s">&quot;graph processing pipeline&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_lines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// a topological order of the graph</span>
<span class="w">  </span><span class="c1">//    |-&gt; B</span>
<span class="w">  </span><span class="c1">// A--|</span>
<span class="w">  </span><span class="c1">//    |-&gt; C</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// the pipeline consists of three serial pipes</span>
<span class="w">  </span><span class="c1">// and up to two concurrent scheduling tokens</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeline</span><span class="w"> </span><span class="n">pl</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="c1">// first pipe calls f1</span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">Pipe</span><span class="p">{</span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">pf</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f1</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()]);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}},</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// second pipe calls f2</span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">Pipe</span><span class="p">{</span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">f2</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}},</span><span class="w"></span>

<span class="w">    </span><span class="c1">// third pipe calls f3</span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">Pipe</span><span class="p">{</span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">f3</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// build the pipeline graph using composition</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">                          </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;starting pipeline&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">pl</span><span class="p">)</span><span class="w"></span>
<span class="w">                          </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;pipeline&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">                          </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;pipeline stopped&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// create task dependency</span>
<span class="w">  </span><span class="n">init</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">task</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">stop</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// dump the pipeline graph structure (with composition)</span>
<span class="w">  </span><span class="n">taskflow</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// run the pipeline</span>
<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><section id="GraphPipelineFindATopologicalOrderOfTheGraph"><h3><a href="#GraphPipelineFindATopologicalOrderOfTheGraph">Find a Topological Order of the Graph</a></h3><p>The first step is to find a valid topological order of the graph, such that we can transform the graph dependency into a linear sequence. In this example, we simply hard-code it:</p><pre class="m-code"><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">};</span><span class="w"></span></pre></section><section id="GraphPipelineDefineTheStageFunction"><h3><a href="#GraphPipelineDefineTheStageFunction">Define the Stage Function</a></h3><p>This particular workload does not propagate data directly through the pipeline. In most situations, data is directly stored in a custom graph data structure, and the stage function will just need to know which node to process. For demo&#x27;s sake, we simply output a message to show which stage function is processing which node:</p><pre class="m-code"><span class="c1">// 1st-stage function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f1(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 2nd-stage function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f2(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 3rd-stage function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f3(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><aside class="m-note m-info"><h4>Note</h4><p>A key advantage of Taskflow&#x27;s pipeline programming model is that we do not provide any data abstraction but give users full control over data management, which is typically application-dependent. In an application like this graph processing pipeline, data is managed in a global custom graph data structure, and any data abstraction provided by the library can become a unnecessary overhead.</p></aside></section><section id="GraphPipelineDefineThePipes"><h3><a href="#GraphPipelineDefineThePipes">Define the Pipes</a></h3><p>The pipe structure is straightforward. Each pipe encapsulates the corresponding stage function and passes the node into the function argument. The first pipe will cease the pipeline scheduling when it has processed all nodes. To identify which node is being processed at a running pipe, we use <a href="classtf_1_1Pipeflow.html#a295e5d884665c076f4ef5d78139f7c51" class="m-doc">tf::<wbr />Pipeflow::<wbr />token</a> to find the index:</p><pre class="m-code"><span class="c1">// first pipe calls f1</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Pipe</span><span class="p">{</span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pf</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f1</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}},</span><span class="w"></span>

<span class="c1">// second pipe calls f2</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Pipe</span><span class="p">{</span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">f2</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()]);</span><span class="w"></span>
<span class="p">}},</span><span class="w"></span>

<span class="c1">// third pipe calls f3</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Pipe</span><span class="p">{</span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">f3</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">()]);</span><span class="w"></span>
<span class="p">}}</span><span class="w"></span></pre></section><section id="GraphPipelineDefineTheTaskGraph"><h3><a href="#GraphPipelineDefineTheTaskGraph">Define the Task Graph</a></h3><p>To build up the taskflow for the pipeline, we create a module task with the defined pipeline structure and connect it with two tasks that output helper messages before and after the pipeline:</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;starting pipeline&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">pl</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;pipeline&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;pipeline stopped&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">init</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="n">task</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">stop</span><span class="p">);</span><span class="w"></span></pre><div class="m-graph"><svg style="width: 31.700rem; height: 32.700rem;" viewBox="0.00 0.00 317.00 327.00">
<g transform="scale(1 1) rotate(0) translate(4 323)">
<title>Taskflow</title>
<g class="m-cluster">
<title>cluster_p0x7ffd7418c200</title>
<polygon points="8,-8 8,-311 151,-311 151,-8 8,-8"/>
<text text-anchor="middle" x="79.5" y="-299" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">Graph Processing Pipeline</text>
</g>
<g class="m-cluster">
<title>cluster_p0x7ffd7418c110</title>
<polygon points="159,-119 159,-311 301,-311 301,-119 159,-119"/>
<text text-anchor="middle" x="230" y="-299" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">m1</text>
</g>
<g class="m-node m-flat">
<title>p0x7bc4000142e8</title>
<ellipse cx="79" cy="-266" rx="56.5233" ry="18"/>
<text text-anchor="middle" x="79" y="-263.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">starting pipeline</text>
</g>
<g class="m-node m-flat">
<title>p0x7bc4000143d0</title>
<polygon points="120,-163 42,-163 38,-159 38,-127 116,-127 120,-131 120,-163"/>
<polyline points="116,-159 38,-159 "/>
<polyline points="116,-159 116,-127 "/>
<polyline points="116,-159 120,-163 "/>
<text text-anchor="middle" x="79" y="-142.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">pipeline [m1]</text>
</g>
<g class="m-edge">
<title>p0x7bc4000142e8&#45;&gt;p0x7bc4000143d0</title>
<path d="M79,-247.8851C79,-228.1928 79,-196.4608 79,-173.439"/>
<polygon points="82.5001,-173.2387 79,-163.2388 75.5001,-173.2388 82.5001,-173.2387"/>
</g>
<g class="m-node m-flat">
<title>p0x7bc4000144b8</title>
<ellipse cx="79" cy="-34" rx="57.8786" ry="18"/>
<text text-anchor="middle" x="79" y="-31.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">pipeline stopped</text>
</g>
<g class="m-edge">
<title>p0x7bc4000143d0&#45;&gt;p0x7bc4000144b8</title>
<path d="M79,-126.6706C79,-109.2373 79,-82.7482 79,-62.5489"/>
<polygon points="82.5001,-62.3566 79,-52.3566 75.5001,-62.3567 82.5001,-62.3566"/>
</g>
<g class="m-node">
<title>p0x7bc400014030</title>
<polygon points="227,-284 193.8992,-266 227,-248 260.1008,-266 227,-284"/>
<text text-anchor="middle" x="227" y="-263.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">cond</text>
</g>
<g class="m-node m-flat">
<title>p0x7bc400014118</title>
<polygon points="221,-163 167,-163 167,-159 163,-159 163,-155 167,-155 167,-135 163,-135 163,-131 167,-131 167,-127 221,-127 221,-163"/>
<polyline points="167,-159 171,-159 171,-155 167,-155 "/>
<polyline points="167,-135 171,-135 171,-131 167,-131 "/>
<text text-anchor="middle" x="194" y="-142.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">rt&#45;0</text>
</g>
<g class="m-edge">
<title>p0x7bc400014030&#45;&gt;p0x7bc400014118</title>
<path stroke-dasharray="5,2" d="M222.6858,-250.1814C217.3593,-230.6507 208.2047,-197.0838 201.6698,-173.1225"/>
<polygon points="204.9696,-171.9194 198.9616,-163.1927 198.2162,-173.7612 204.9696,-171.9194"/>
<text text-anchor="middle" x="214.5" y="-203" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">0</text>
</g>
<g class="m-node m-flat">
<title>p0x7bc400014200</title>
<polygon points="293,-163 239,-163 239,-159 235,-159 235,-155 239,-155 239,-135 235,-135 235,-131 239,-131 239,-127 293,-127 293,-163"/>
<polyline points="239,-159 243,-159 243,-155 239,-155 "/>
<polyline points="239,-135 243,-135 243,-131 239,-131 "/>
<text text-anchor="middle" x="266" y="-142.5" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">rt&#45;1</text>
</g>
<g class="m-edge">
<title>p0x7bc400014030&#45;&gt;p0x7bc400014200</title>
<path stroke-dasharray="5,2" d="M231.9394,-250.6753C238.2165,-231.2 249.1705,-197.2146 256.9606,-173.0452"/>
<polygon points="260.3461,-173.9504 260.0827,-163.3588 253.6837,-171.8029 260.3461,-173.9504"/>
<text text-anchor="middle" x="250.5" y="-203" font-family="Helvetica,sans-Serif" font-size="10.00" fill="#000000">1</text>
</g>
</g>
</svg>
</div></section><section id="GraphPipelineSubmitTheTaskGraph"><h3><a href="#GraphPipelineSubmitTheTaskGraph">Submit the Task Graph</a></h3><p>Finally, we submit the taskflow to the execution and run it once:</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span><span class="w"></span></pre><p>Three possible outputs are shown below:</p><pre class="m-console"><span class="gp"># </span>possible output <span class="m">1</span>
<span class="go">ready</span>
<span class="go">f1(A)</span>
<span class="go">f2(A)</span>
<span class="go">f1(B)</span>
<span class="go">f2(B)</span>
<span class="go">f3(A)</span>
<span class="go">f1(C)</span>
<span class="go">f2(C)</span>
<span class="go">f3(B)</span>
<span class="go">f3(C)</span>
<span class="go">stopped</span>

<span class="gp"># </span>possible output <span class="m">2</span>
<span class="go">f1(A)</span>
<span class="go">f2(A)</span>
<span class="go">f3(A)</span>
<span class="go">f1(B)</span>
<span class="go">f2(B)</span>
<span class="go">f3(B)</span>
<span class="go">f1(C)</span>
<span class="go">f2(C)</span>
<span class="go">f3(C)</span>
<span class="go">stopped</span>

<span class="gp"># </span>possible output <span class="m">3</span>
<span class="go">ready</span>
<span class="go">f1(A)</span>
<span class="go">f2(A)</span>
<span class="go">f3(A)</span>
<span class="go">f1(B)</span>
<span class="go">f2(B)</span>
<span class="go">f1(C)</span>
<span class="go">f2(C)</span>
<span class="go">f3(B)</span>
<span class="go">f3(C)</span>
<span class="go">stopped</span></pre></section></section><section id="GraphPipelineReference"><h2><a href="#GraphPipelineReference">Reference</a></h2><p>We have applied the graph processing pipeline technique to speed up a circuit analysis problem. Details can be referred to our publication below:</p><ul><li>Cheng-Hsiang Chiu and Tsung-Wei Huang, &quot;<a href="https://tsung-wei-huang.github.io/papers/dac2022.pdf">Efficient Timing Propagation with Simultaneous Structural and Pipeline Parallelisms</a>,&quot; <em>ACM/IEEE Design Automation Conference (DAC)</em>, San Francisco, CA, 2022</li></ul></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright © <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2023.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.8.14 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
